<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAP PATH FINDER</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0c0c1a;
            color: #fff;
            overflow-x: hidden;
            height: 100vh;
        }

        #home-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0c0c1a 0%, #1a1a3a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.8s ease;
        }

        #home-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .logo {
            margin-bottom: 2rem;
            text-align: center;
        }

        .logo h1 {
            font-size: 3.5rem;
            background: linear-gradient(45deg, #4169E1, #6A5ACD, #9370DB);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 20px rgba(100, 149, 237, 0.3);
        }

        .logo p {
            font-size: 1.2rem;
            color: #a0a0d0;
        }

        .start-button {
            background: linear-gradient(45deg, #4169E1, #6A5ACD);
            border: none;
            color: white;
            padding: 1.2rem 3rem;
            font-size: 1.4rem;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 2rem;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(65, 105, 225, 0.4);
        }

        .start-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(65, 105, 225, 0.6);
        }

        .start-button:active {
            transform: translateY(1px);
        }

        .loading-progress {
            margin-top: 2rem;
            width: 300px;
            text-align: center;
        }

        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4169E1, #6A5ACD);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 4px;
        }

        .progress-text {
            color: #a0a0d0;
            font-size: 0.9rem;
        }

        .container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            opacity: 0;
            transition: opacity 0.8s ease;
        }

        .container.visible {
            opacity: 1;
        }

        header {
            background: linear-gradient(135deg, #1a1a3a 0%, #0c0c1a 100%);
            padding: 1rem;
            border-bottom: 1px solid #2a2a4a;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            z-index: 1000;
            min-height: 60px;
        }

        .header-controls {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.8rem;
            flex: 1;
            align-items: center;
        }

        .header-title {
            flex: 1;
            text-align: right;
        }

        h1 {
            font-size: 1.8rem;
            color: #fff;
            text-shadow: 0 0 10px rgba(100, 149, 237, 0.5);
        }

        .subtitle {
            text-align: center;
            color: #a0a0d0;
            font-size: 0.9rem;
            display: none;
        }

        .content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            position: relative;
        }

        .viewer-container {
            position: relative;
            width: 100%;
            height: 100%;
            flex-grow: 1;
            overflow: hidden;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(28, 28, 48, 0.9);
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            z-index: 100;
        }

        .loading.hidden {
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #4169E1;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #loading-message {
            margin-bottom: 0.5rem;
            color: #fff;
        }

        #loading-submessage {
            color: #a0a0d0;
            font-size: 0.9rem;
        }

        .dropdown {
            position: relative;
            min-width: 120px;
            z-index: 1000;
        }

        .dropdown-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: rgba(50, 50, 80, 0.6);
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.3s;
            min-height: 32px;
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dropdown-header:hover {
            background: rgba(70, 70, 100, 0.9);
        }

        .dropdown-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(40, 40, 65, 0.95);
            border-radius: 6px;
            margin-top: 0.2rem;
            overflow: hidden;
            max-height: 0;
            opacity: 0;
            transition: all 0.4s ease;
            z-index: 1001;
            border: 1px solid #2a2a4a;
        }

        .dropdown.open .dropdown-options {
            max-height: 200px;
            opacity: 1;
            overflow-y: auto;
        }

        .dropdown-option {
            padding: 0.6rem;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid #2a2a4a;
            min-height: 36px;
            display: flex;
            align-items: center;
            font-size: 0.9rem;
        }

        .dropdown-option:hover {
            background: rgba(90, 90, 140, 0.8);
        }

        .dropdown-option.selected {
            background: #4169E1;
            color: white;
        }

        .dropdown-option:last-child {
            border-bottom: none;
        }

        .btn {
            padding: 0.5rem 0.8rem;
            background: rgba(50, 50, 80, 0.8);
            border: 1px solid #2a2a4a;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
            min-height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .btn:hover {
            background: rgba(70, 70, 100, 0.9);
            transform: translateY(-2px);
        }

        .btn.primary {
            background: #4169E1;
        }

        .btn.primary:hover {
            background: #5a7de9;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn:disabled:hover {
            background: rgba(50, 50, 80, 0.8);
            transform: none;
        }

        .generate-path-btn {
            padding: 0.5rem 0.8rem;
            background: #4169E1;
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
            border: 1px solid #2a2a4a;
            min-height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .generate-path-btn:hover {
            background: #5a7de9;
            transform: translateY(-2px);
        }

        .generate-path-btn:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }

        .speed-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.3rem;
            min-width: 100px;
        }

        .speed-control label {
            font-size: 0.7rem;
            color: #a0a0d0;
            text-align: center;
            white-space: nowrap;
        }

        .speed-slider {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #4169E1;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(65, 105, 225, 0.3);
            transition: all 0.2s ease;
        }

        .speed-slider::-webkit-slider-thumb:hover {
            background: #5a7de9;
            transform: scale(1.1);
        }

        .speed-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #4169E1;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(65, 105, 225, 0.3);
        }

        .speed-value {
            font-size: 0.7rem;
            color: #4169E1;
            font-weight: bold;
            min-width: 30px;
            text-align: center;
        }


        .location-highlight {
            position: absolute;
            padding: 0.5rem 1rem;
            background: rgba(65, 105, 225, 0.2);
            border-radius: 20px;
            font-size: 0.9rem;
            color: #4169E1;
            pointer-events: none;
            transform: translate(-50%, -100%);
            white-space: nowrap;
            z-index: 10;
            backdrop-filter: blur(5px);
            border: 1px solid #4169E1;
        }

        .location-highlight::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 10px;
            height: 10px;
            background: #4169E1;
            border-radius: 50%;
        }

        .department-locations {
            display: none;
            grid-column: span 3;
            gap: 0.8rem;
            align-items: center;
            grid-template-columns: 1fr 1fr;
        }

        .department-locations.visible {
            display: grid;
        }


        @media (max-width: 768px) {
            header {
                flex-direction: column;
                gap: 0.8rem;
            }
            
            .header-controls {
                width: 100%;
                grid-template-columns: repeat(3, 1fr);
                gap: 0.6rem;
            }
            
            .header-title {
                text-align: center;
                width: 100%;
            }
            
            .dropdown {
                min-width: 100px;
            }
            
            .department-locations {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
            
            
            .logo h1 {
                font-size: 2.5rem;
            }
            
        }
    </style>
</head>
<body>
    <!-- Home Screen -->
    <div id="home-screen">
        <div class="logo">
            <h1>Map Path Finder</h1>
            <p>Explore your campus in 3D</p>
        </div>
        
        <div class="loading-progress">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="progress-text" id="progress-text">Loading resources... 0%</div>
        </div>
        
        <button class="start-button" id="start-button" disabled>PATHFINDER</button>
    </div>

    <!-- Main App Container (initially hidden) -->
    <div class="container" id="app-container">
        <header>
            <div class="header-controls">
                <div class="dropdown" id="department-dropdown">
                    <div class="dropdown-header">
                        <span id="department-dropdown-text">Department</span>
                        <span>▼</span>
                    </div>
                    <div class="dropdown-options" id="department-dropdown-options"></div>
                </div>
                
                <div class="department-locations" id="department-locations">
                    <div class="dropdown" id="locationA-dropdown">
                        <div class="dropdown-header">
                            <span id="locationA-dropdown-text">CCIS Start</span>
                            <span>▼</span>
                        </div>
                        <div class="dropdown-options" id="locationA-dropdown-options"></div>
                    </div>
                    
                    <div class="dropdown" id="locationB-dropdown">
                        <div class="dropdown-header">
                            <span id="locationB-dropdown-text">CCIS End</span>
                            <span>▼</span>
                        </div>
                        <div class="dropdown-options" id="locationB-dropdown-options"></div>
                    </div>
                </div>
                
                <div class="dropdown" id="from-dropdown">
                    <div class="dropdown-header">
                        <span id="from-dropdown-text">Start</span>
                        <span>▼</span>
                    </div>
                    <div class="dropdown-options" id="from-dropdown-options"></div>
                </div>
                
                <div class="dropdown" id="to-dropdown">
                    <div class="dropdown-header">
                        <span id="to-dropdown-text">End</span>
                        <span>▼</span>
                    </div>
                    <div class="dropdown-options" id="to-dropdown-options"></div>
                </div>
                
                <button id="start-path" class="generate-path-btn" disabled>Start</button>
                
                <div class="speed-control">
                    <label for="speed-slider">Speed</label>
                    <input type="range" id="speed-slider" class="speed-slider" min="0.1" max="3" step="0.1" value="1">
                    <div class="speed-value" id="speed-value">1.0x</div>
                </div>
                
            </div>
            
            <div class="header-title">
                <h1>Map Path Finder</h1>
            </div>
        </header>
        
        <div class="content">
            <div class="viewer-container">
                <div id="canvas-container"></div>
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <h3 id="loading-message">Loading Campus Data...</h3>
                    <p id="loading-submessage">Preparing path visualization</p>
                </div>
            </div>
        </div>
        
    </div>

    <!-- Using UMD versions for compatibility -->
    <script src="./threejs/three.min.js"></script>
    <script src="./threejs/GLTFLoader.min.js"></script>
    <script src="./threejs/OrbitControls.js"></script>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let model = null;
        let pathLine = null;
        let personModel = null;
        let selectedFromPoint = null;
        let selectedToPoint = null;
        let selectedDepartment = null;
        let selectedLocationA = null;
        let selectedLocationB = null;
        let currentPath = null;
        let isWalking = false;
        let walkingProgress = 0;
        let cameraFollowing = false;
        let isFlyMode = true;
        let personDirection = new THREE.Vector3(0, 0, 1);
        let arrivalMessage = null;
        let walkingSpeed = 1.0; // Default walking speed multiplier
        
        // Camera positions for different stair areas
        const CAMERA_POSITIONS = {
            "floor_1_1": {
                "position": [-12.0453, 0.8356, 0.6005],
                "target": [-16.6525, 1.8125, 9.422]
            },
            "floor_1_2": {
                "position": [-12.0453, 0.8856, 0.6005],
                "target": [-19.9398, -0.4321, 6.5956]
            },
            "floor_1_3": {
                "position": [-12.1189, 1.0789, 0.6679],
                "target": [-17.7595, 1.1175, 8.9251]
            },
            "floor_2_2": {
                "position": [-15.8478, 0.9141, 0.7219],
                "target": [-10.271, -1.7354, 8.5883]
            },
            "floor_2_3": {
                "position": [-15.8478, 1.2141, 0.7219],
                "target": [-11.5703, -2.31, 9.0456]
            },
            "floor_3_3": {
                "position": [-18.7197, 1.1725, 0.7182],
                "target": [-21.6955, -2.6122, 9.4829]
            },
            "floor_3_2": {
                "position": [-18.7197, 0.9225, 0.7182],
                "target": [-21.5813, -2.3193, 9.735]
            }, "floor_2_1": {
        "position": [
            -15.7836,
            0.646,
            0.6705
        ],
        "target": [
            -12.1716,
            -0.8643,
            9.8722
        ]
    },
    "floor_3_1": {
        "position": [
            -18.9701,
            0.6105,
            0.6365
        ],
        "target": [
            -14.3903,
            0.2544,
            9.5189
        ]
    }
        };
        
        let isStairView = false;
        let currentStairPosition = null;
        
        // Function to check if person is near stair coordinates and get appropriate camera position
        function getStairCameraPosition(position) {
            // Define proximity thresholds for different coordinates - tighter for precise detection
            const xThreshold = 0.5; // X coordinate threshold - moderate range
            const yThreshold = 0.1; // Y coordinate threshold - moderate range
            const zThreshold = 0.8; // Z coordinate threshold - moderate range
            
            for (const [areaName, cameraPos] of Object.entries(CAMERA_POSITIONS)) {
                const cameraPosition = new THREE.Vector3(...cameraPos.position);
                
                // Check if within threshold for each coordinate
                const xDiff = Math.abs(position.x - cameraPosition.x);
                const yDiff = Math.abs(position.y - cameraPosition.y);
                const zDiff = Math.abs(position.z - cameraPosition.z);
                
                console.log(`Checking ${areaName}: xDiff=${xDiff.toFixed(2)}, yDiff=${yDiff.toFixed(2)}, zDiff=${zDiff.toFixed(2)}`);
                
                if (xDiff <= xThreshold && yDiff <= yThreshold && zDiff <= zThreshold) {
                    console.log(`Found stair area: ${areaName}`);
                    return areaName;
                }
            }
            
            return null; // Not near any stair area
        }
        
        // JSON data variables
        let CAMPUS_POINTS = {};
        let PREDEFINED_PATHS = {};
        
        // Department data with camera positions
        const DEPARTMENTS = {
            'CCIS': {
                name: 'College of Computing and Information Sciences',
                hasLocations: true,
                camera: { position: [-11.4023, 3.1333, -6.5408], target: [-12.8938, 2.2596, -2.5850] }
            },
            'CRIM': {
                name: 'College of Criminal Justice',
                hasLocations: false,
                camera: { position: [-7.0789, 2.6126, -6.3270], target: [-12.8938, 2.2596, -5.5850] }
            },
            'COM': {
                name: 'College of Management',
                hasLocations: false,
                camera: { position: [-1.5614, 5.0422, 0.7315], target: [12.8938, 2.2596, -5.5850] }
            },
            'DEFAULT': {
                name: 'General Campus',
                hasLocations: false,
                camera: { position: [18.0607, 5.2207, -1.8569], target: [8.6538, 3.2521, -4.6200] }
            }
        };
        
        // CCIS-specific locations (these will be populated from JSON)
        let CCIS_LOCATIONS = [];
        
        
        
        // Resource tracking
        let resourcesLoaded = 0;
        let totalResources = 2; // JSON data and model
        let preloadedModel = null; // Store the preloaded model

        // Preload resources
        async function preloadResources() {
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            const startButton = document.getElementById('start-button');
            
            try {
                // Update progress
                updateProgress(10, 'Loading path data...');
                
                // Load JSON data
                await loadJSONData();
                resourceLoaded();
                
                // Update progress
                updateProgress(40, 'Loading campus model...');
                
                // Load the model but don't add to scene yet
                preloadedModel = await loadModel();
                resourceLoaded();
                
                // Final update
                updateProgress(100, 'Ready!');
                
                // Enable the start button
                startButton.disabled = false;
                
            } catch (error) {
                console.error('Error preloading resources:', error);
                progressText.textContent = 'Error loading resources. Using fallback data.';
                progressText.style.color = '#ff6b6b';
                
                // Enable the start button even if there was an error
                startButton.disabled = false;
            }
        }
        
        function updateProgress(percent, message) {
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            
            progressFill.style.width = percent + '%';
            progressText.textContent = message + ' ' + percent + '%';
        }
        
        function resourceLoaded() {
            resourcesLoaded++;
            const percent = 10 + (resourcesLoaded / totalResources) * 90;
            updateProgress(Math.round(percent), 'Loading resources...');
        }
        
        // Initialize the home screen
        function initHomeScreen() {
            const startButton = document.getElementById('start-button');
            const homeScreen = document.getElementById('home-screen');
            const appContainer = document.getElementById('app-container');
            
            startButton.addEventListener('click', () => {
                // Fade out home screen
                homeScreen.classList.add('fade-out');
                
                // Show app container after a delay
                setTimeout(() => {
                    appContainer.classList.add('visible');
                    initApp();
                }, 800);
            });
            
            // Start preloading resources
            preloadResources();
        }
        
        // Initialize the app
        function initApp() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0c0c1a);
            scene.fog = new THREE.Fog(0x0c0c1a, 10, 50);
            
            // Create camera - position it closer to the model
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(-25.1283, 3.0082, -1.4318);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                logarithmicDepthBuffer: true
            });
            
            const container = document.getElementById('canvas-container');
            
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            renderer.shadowMap.enabled = false;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // Add grid helper
            const gridHelper = new THREE.GridHelper(40, 20, 0x444466, 0x222244);
            gridHelper.position.y = -0.01;
            scene.add(gridHelper);
            
            // Lighting setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
            directionalLight.position.set(20, 30, 20);
            scene.add(directionalLight);
            
            const fillLight = new THREE.DirectionalLight(0xffffff, 1.5);
            fillLight.position.set(-20, 20, 20);
            scene.add(fillLight);
            
            // Add the preloaded model to the scene if available
            if (preloadedModel) {
                console.log('Adding preloaded model to scene...');
                scene.add(preloadedModel);
                model = preloadedModel;
                console.log('Model added to scene, model object:', model);
            } else {
                console.log('No preloaded model, creating placeholder...');
                // Create a placeholder model if preloading failed
                createPlaceholderModel();
            }
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.maxDistance = 150;
            controls.minDistance = 1; // Allow getting much closer
            controls.maxPolarAngle = Math.PI / 1.5;
            
            // Set the initial target
            controls.target.set(12.8938, 2.2596, -5.5850);
            controls.update();
            
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            
            // Initialize basic keyboard controls
            initKeyboardControls();
            
            // Create person model
            createPersonModel();
            
            // Initialize UI after data is loaded
            initUI();
            
            // Start animation loop
            animate();
            
            // Hide the loading indicator
            document.getElementById('loading').classList.add('hidden');
        }
        
        // Initialize basic keyboard controls
        function initKeyboardControls() {
            // No keyboard controls needed - just orbit controls
        }
            
            // No additional touch/mouse controls - just use orbit control
        
        // Initialize mobile control buttons
        function initMobileControls() {
            // No mobile controls needed - just orbit controls
        }
        
        async function loadJSONData() {
            try {
                // Try to load from path.json
                const response = await fetch('path.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const jsonData = await response.json();
                CAMPUS_POINTS = jsonData.locations;
                PREDEFINED_PATHS = jsonData.paths;
                
                // Populate CCIS locations from JSON
                // These are the CCIS-specific locations (rooms, labs, etc.)
                CCIS_LOCATIONS = Object.keys(jsonData.locations);
                
                console.log('CCIS Locations loaded:', CCIS_LOCATIONS);
                
            } catch (error) {
                console.error('Error loading JSON data:', error);
                
                // Use sample data as fallback
                CAMPUS_POINTS = {
                    "Main Entrance": {x: 0, y: 0, z: 0},
                    "Library": {x: 8, y: 0, z: 5},
                    "Cafeteria": {x: -6, y: 0, z: 7},
                    "Administration": {x: 3, y: 0, z: -4},
                    "Student Center": {x: -5, y: 0, z: -3}
                };
                
                PREDEFINED_PATHS = {
                    "Main_Entrance_Library": {
                        path: [
                            {x: 0, y: 0.1, z: 0},
                            {x: 4, y: 0.1, z: 2.5},
                            {x: 8, y: 0.1, z: 5}
                        ]
                    },
                    "Main_Entrance_Cafeteria": {
                        path: [
                            {x: 0, y: 0.1, z: 0},
                            {x: -3, y: 0.1, z: 3.5},
                            {x: -6, y: 0.1, z: 7}
                        ]
                    }
                };
            
            }
        }
        
        function initUI() {
            // Populate department dropdown
            const departmentOptions = document.getElementById('department-dropdown-options');
            Object.keys(DEPARTMENTS).forEach(deptKey => {
                const deptOption = document.createElement('div');
                deptOption.className = 'dropdown-option';
                deptOption.textContent = DEPARTMENTS[deptKey].name;
                deptOption.dataset.value = deptKey;
                deptOption.addEventListener('click', function() {
                    document.querySelectorAll('#department-dropdown .dropdown-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    deptOption.classList.add('selected');
                    document.getElementById('department-dropdown-text').textContent = DEPARTMENTS[deptKey].name;
                    selectedDepartment = deptKey;
                    document.getElementById('department-dropdown').classList.remove('open');
                    
                    // Move camera to department position
                    moveCameraToDepartment(deptKey);
                    
                    // Show/hide department locations based on selection
                    toggleDepartmentLocations();
                    
                    // Update generate path button
                    updateGeneratePathButton();
                });
                departmentOptions.appendChild(deptOption);
            });
            
            // Populate location A and B dropdowns with CCIS locations (initially hidden)
            const locationAOptions = document.getElementById('locationA-dropdown-options');
            const locationBOptions = document.getElementById('locationB-dropdown-options');
            
            // Add CCIS locations to both dropdowns
            CCIS_LOCATIONS.forEach(locationName => {
                // Create a more readable display name
                const displayName = locationName.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                
                // Location A dropdown (Start)
                const locationAOption = document.createElement('div');
                locationAOption.className = 'dropdown-option';
                locationAOption.textContent = displayName;
                locationAOption.dataset.value = locationName;
                locationAOption.addEventListener('click', function() {
                    document.querySelectorAll('#locationA-dropdown .dropdown-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    locationAOption.classList.add('selected');
                    document.getElementById('locationA-dropdown-text').textContent = displayName;
                    selectedLocationA = locationName;
                    document.getElementById('locationA-dropdown').classList.remove('open');
                    updateGeneratePathButton();
                });
                locationAOptions.appendChild(locationAOption);
                
                // Location B dropdown (End)
                const locationBOption = document.createElement('div');
                locationBOption.className = 'dropdown-option';
                locationBOption.textContent = displayName;
                locationBOption.dataset.value = locationName;
                locationBOption.addEventListener('click', function() {
                    document.querySelectorAll('#locationB-dropdown .dropdown-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    locationBOption.classList.add('selected');
                    document.getElementById('locationB-dropdown-text').textContent = displayName;
                    selectedLocationB = locationName;
                    document.getElementById('locationB-dropdown').classList.remove('open');
                    updateGeneratePathButton();
                });
                locationBOptions.appendChild(locationBOption);
            });
            
            // Populate regular from/to dropdowns
            const fromOptions = document.getElementById('from-dropdown-options');
            const toOptions = document.getElementById('to-dropdown-options');
            
            Object.keys(CAMPUS_POINTS).forEach(locationName => {
                // From dropdown
                const fromOption = document.createElement('div');
                fromOption.className = 'dropdown-option';
                fromOption.textContent = locationName;
                fromOption.dataset.value = locationName;
                fromOption.addEventListener('click', function() {
                    document.querySelectorAll('#from-dropdown .dropdown-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    fromOption.classList.add('selected');
                    document.getElementById('from-dropdown-text').textContent = locationName;
                    selectedFromPoint = locationName;
                    document.getElementById('from-dropdown').classList.remove('open');
                    
                    // Enable generate path button if both points are selected
                    updateGeneratePathButton();
                    
                    // Navigate to lookout when both points are selected
                    if (selectedFromPoint && selectedToPoint) {
                        navigateToLookout();
                    }
                });
                fromOptions.appendChild(fromOption);
                
                // To dropdown
                const toOption = document.createElement('div');
                toOption.className = 'dropdown-option';
                toOption.textContent = locationName;
                toOption.dataset.value = locationName;
                toOption.addEventListener('click', () => {
                    document.querySelectorAll('#to-dropdown .dropdown-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    toOption.classList.add('selected');
                    document.getElementById('to-dropdown-text').textContent = locationName;
                    selectedToPoint = locationName;
                    document.getElementById('to-dropdown').classList.remove('open');
                    
                    // Enable generate path button if both points are selected
                    updateGeneratePathButton();
                    
                    // Navigate to lookout when both points are selected
                    if (selectedFromPoint && selectedToPoint) {
                        navigateToLookout();
                    }
                });
                toOptions.appendChild(toOption);
            });
            
            // Dropdown toggle
            document.querySelectorAll('.dropdown-header').forEach(header => {
                header.addEventListener('click', function() {
                    const dropdown = this.parentElement;
                    dropdown.classList.toggle('open');
                });
            });
            
            // Button events
            document.getElementById('start-path').addEventListener('click', startPath);
            
            // Speed control events
            const speedSlider = document.getElementById('speed-slider');
            const speedValue = document.getElementById('speed-value');
            
            speedSlider.addEventListener('input', function() {
                walkingSpeed = parseFloat(this.value);
                speedValue.textContent = walkingSpeed.toFixed(1) + 'x';
            });
            
        }
        
        function moveCameraToDepartment(departmentKey) {
            const department = DEPARTMENTS[departmentKey];
            if (department && department.camera) {
                const cameraPos = department.camera.position;
                const cameraTarget = department.camera.target;
                
                // Position camera and look at target
                camera.position.set(cameraPos[0], cameraPos[1], cameraPos[2]);
                camera.lookAt(cameraTarget[0], cameraTarget[1], cameraTarget[2]);
                controls.target.set(cameraTarget[0], cameraTarget[1], cameraTarget[2]);
                controls.update();
            }
        }
        
        function toggleDepartmentLocations() {
            const departmentLocations = document.getElementById('department-locations');
            const regularFromDropdown = document.getElementById('from-dropdown');
            const regularToDropdown = document.getElementById('to-dropdown');
            
            if (selectedDepartment && DEPARTMENTS[selectedDepartment].hasLocations) {
                // Show CCIS Start/End dropdowns, hide regular Start/End dropdowns
                departmentLocations.classList.add('visible');
                regularFromDropdown.style.display = 'none';
                regularToDropdown.style.display = 'none';
            } else {
                // Hide CCIS Start/End dropdowns, hide regular Start/End dropdowns for non-CCIS departments
                departmentLocations.classList.remove('visible');
                regularFromDropdown.style.display = 'none';
                regularToDropdown.style.display = 'none';
                
                // Reset location selections when hiding
                selectedLocationA = null;
                selectedLocationB = null;
                document.getElementById('locationA-dropdown-text').textContent = 'CCIS Start';
                document.getElementById('locationB-dropdown-text').textContent = 'CCIS End';
                document.querySelectorAll('#locationA-dropdown .dropdown-option').forEach(opt => opt.classList.remove('selected'));
                document.querySelectorAll('#locationB-dropdown .dropdown-option').forEach(opt => opt.classList.remove('selected'));
            }
        }
        
        function updateGeneratePathButton() {
            const generateBtn = document.getElementById('start-path');
            
            // Check if we have the required selections based on department
            let canGenerate = false;
            
            if (selectedDepartment && DEPARTMENTS[selectedDepartment].hasLocations) {
                // For departments with locations (like CCIS), need both Location A and Location B selected
                canGenerate = selectedLocationA && selectedLocationB;
            } else {
                // For other departments, use regular from/to selection
                canGenerate = selectedFromPoint && selectedToPoint;
            }
            
            generateBtn.disabled = !canGenerate;
        }
        
        
        // Create person model - Adjusted to be smaller
        function createPersonModel() {
            const personGroup = new THREE.Group();
            
            // Scale factor to make the person smaller
            const scaleFactor = 0.5;
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.03 * scaleFactor, 0.04 * scaleFactor, 0.12 * scaleFactor, 8);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.06 * scaleFactor;
            personGroup.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.025 * scaleFactor, 8, 6);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB5 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.145 * scaleFactor;
            personGroup.add(head);
            
            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.008 * scaleFactor, 0.008 * scaleFactor, 0.08 * scaleFactor, 6);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB5 });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.045 * scaleFactor, 0.08 * scaleFactor, 0);
            leftArm.rotation.z = 0.3;
            personGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.045 * scaleFactor, 0.08 * scaleFactor, 0);
            rightArm.rotation.z = -0.3;
            personGroup.add(rightArm);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.01 * scaleFactor, 0.01 * scaleFactor, 0.08 * scaleFactor, 6);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.015 * scaleFactor, -0.04 * scaleFactor, 0);
            personGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.015 * scaleFactor, -0.04 * scaleFactor, 0);
            personGroup.add(rightLeg);
            
            personModel = personGroup;
            personModel.visible = false;
            scene.add(personModel);
        }
        
        // Navigate to lookout when both points are selected
        function navigateToLookout() {
            if (!selectedFromPoint || !CAMPUS_POINTS[selectedFromPoint]) return;
            
            const lookoutPoint = CAMPUS_POINTS[selectedFromPoint];
            const targetPosition = new THREE.Vector3(lookoutPoint.x, lookoutPoint.y + 2, lookoutPoint.z + 5);
            const lookAtPosition = new THREE.Vector3(lookoutPoint.x, lookoutPoint.y, lookoutPoint.z);
            
            // Position camera and look at target
            camera.position.copy(targetPosition);
            camera.lookAt(lookAtPosition);
            controls.target.copy(lookAtPosition);
            controls.update();
        }
        

        function startPath() {
            // Check if we have the required selections based on department
            if (selectedDepartment && DEPARTMENTS[selectedDepartment].hasLocations) {
                if (!selectedLocationA || !selectedLocationB) {
                    alert('Please select both Start and End locations');
                    return;
                }
                if (selectedLocationA === selectedLocationB) {
                    alert('Start and End locations cannot be the same');
                    return;
                }
            } else {
                if (!selectedFromPoint || !selectedToPoint) {
                    alert('Please select both start and end locations');
                    return;
                }
                if (selectedFromPoint === selectedToPoint) {
                    alert('Start and end locations cannot be the same');
                    return;
                }
            }
            
            clearPath();
            
            let pathData = null;
            let path = null;
            let isReversed = false;
            
            if (selectedDepartment && DEPARTMENTS[selectedDepartment].hasLocations) {
                // For departments with locations (like CCIS), use predefined paths from JSON
                const pathKey = `${selectedLocationA}_${selectedLocationB}`;
                const reversePathKey = `${selectedLocationB}_${selectedLocationA}`;
                
                // Try to find predefined path
                if (PREDEFINED_PATHS[pathKey]) {
                    pathData = PREDEFINED_PATHS[pathKey];
                    path = pathData.path;
                } else if (PREDEFINED_PATHS[reversePathKey]) {
                    pathData = PREDEFINED_PATHS[reversePathKey];
                    path = [...pathData.path].reverse(); // Reverse the path array
                    isReversed = true;
                } else {
                    // Fallback: create a simple path between the two locations
                    const locationACoords = CAMPUS_POINTS[selectedLocationA];
                    const locationBCoords = CAMPUS_POINTS[selectedLocationB];
                    
                    if (!locationACoords || !locationBCoords) {
                        alert('Location coordinates not found');
                        return;
                    }
                    
                    path = [
                        {x: locationACoords.x, y: locationACoords.y + 0.02, z: locationACoords.z},
                        {x: (locationACoords.x + locationBCoords.x)/2, y: Math.max(locationACoords.y, locationBCoords.y) + 1.0, z: (locationACoords.z + locationBCoords.z)/2},
                        {x: locationBCoords.x, y: locationBCoords.y + 0.02, z: locationBCoords.z}
                    ];
                }
            } else {
                // For other departments, use regular path logic
                const pathKey = `${selectedFromPoint}_${selectedToPoint}`;
                const reversePathKey = `${selectedToPoint}_${selectedFromPoint}`;
                
                // Try to find predefined path
                if (PREDEFINED_PATHS[pathKey]) {
                    pathData = PREDEFINED_PATHS[pathKey];
                    path = pathData.path;
                } else if (PREDEFINED_PATHS[reversePathKey]) {
                    pathData = PREDEFINED_PATHS[reversePathKey];
                    path = [...pathData.path].reverse(); // Reverse the path array
                    isReversed = true;
                } else {
                    // Create a direct path as fallback
                    const start = CAMPUS_POINTS[selectedFromPoint];
                    const end = CAMPUS_POINTS[selectedToPoint];
                    
                    if (!start || !end) return;
                    
                    path = [
                        {x: start.x, y: start.y + 0.02, z: start.z},
                        {x: (start.x + end.x)/2, y: Math.max(start.y, end.y) + 1.0, z: (start.z + end.z)/2},
                        {x: end.x, y: end.y + 0.02, z: end.z}
                    ];
                }
            }
            
            // Create visualization
            if (path) {
                const pathCoordinates = path.map(p => new THREE.Vector3(p.x, p.y, p.z));
                
                // Use straight line segments instead of curved tubes
                const geometry = new THREE.BufferGeometry().setFromPoints(pathCoordinates);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x00ff00,
                    linewidth: 5,
                    transparent: true,
                    opacity: 0.9
                });
                
                pathLine = new THREE.Line(geometry, material);
                scene.add(pathLine);
                
                currentPath = pathCoordinates;
                
                
                // Position person at start (with height offset to keep above ground)
                const startPosition = pathCoordinates[0].clone();
                startPosition.y += 0.05; // Lift person slightly above ground
                personModel.position.copy(startPosition);
                personModel.visible = true;
                
                // Position camera at the start location
                const startPoint = pathCoordinates[0];
                
                // Determine person direction based on path
                if (pathCoordinates.length > 1) {
                    personDirection = new THREE.Vector3().subVectors(pathCoordinates[1], startPoint).normalize();
                } else {
                    personDirection = new THREE.Vector3(0, 0, 1); // Default forward direction
                }
                
                // Calculate left direction (perpendicular to path direction)
                const leftDirection = new THREE.Vector3(-personDirection.z, 0, personDirection.x).normalize();
                
                // Set person to look left relative to path direction
                const lookAtPoint = startPoint.clone().add(leftDirection);
                
                // First-person view: position camera at person's eye level
                const eyeLevel = 1.6; // Human eye level height
                const cameraPosition = startPoint.clone().add(new THREE.Vector3(0, eyeLevel, 0));
                
                // Position camera at start position
                camera.position.copy(cameraPosition);
                camera.lookAt(lookAtPoint);
                controls.target.copy(lookAtPoint);
                controls.update();
                
                // Automatically start walking
                startWalking();
            }
        }

        function startWalking() {
            if (!currentPath || currentPath.length === 0) {
                alert('Please generate a path first');
                return;
            }
            
                // Position person at start point immediately
                if (currentPath.length > 0) {
                    const startPosition = currentPath[0].clone();
                    startPosition.y += 0.05; // Lift person slightly above ground
                    personModel.position.copy(startPosition);
                    
                    // Calculate left direction relative to path direction
                    let pathDirection;
                    if (currentPath.length > 1) {
                        pathDirection = new THREE.Vector3().subVectors(currentPath[1], currentPath[0]).normalize();
                    } else {
                        pathDirection = new THREE.Vector3(0, 0, 1); // Default forward direction
                    }
                    
                    // Calculate left direction (perpendicular to path direction)
                    const leftDirection = new THREE.Vector3(-pathDirection.z, 0, pathDirection.x).normalize();
                    
                    // Set person to look left relative to path direction
                    personDirection = leftDirection;
                    if (personDirection.length() > 0) {
                        personModel.lookAt(personModel.position.clone().add(personDirection));
                    }
                }
            
            // Position camera at first coordinate of the path immediately
            if (currentPath.length > 0) {
                const firstCoordinate = currentPath[0];
                const eyeLevel = 0.06;
                const distanceBack = 0.3;
                
                // Calculate camera position behind the person
                const cameraDirection = personDirection.clone().multiplyScalar(-distanceBack);
                cameraDirection.y = eyeLevel;
                
                // Set camera to first coordinate position
                camera.position.copy(firstCoordinate).add(cameraDirection);
                
                // Calculate left direction relative to path direction for camera
                let pathDirection;
                if (currentPath.length > 1) {
                    pathDirection = new THREE.Vector3().subVectors(currentPath[1], currentPath[0]).normalize();
                } else {
                    pathDirection = new THREE.Vector3(0, 0, 1); // Default forward direction
                }
                
                // Calculate left direction (perpendicular to path direction)
                const leftDirection = new THREE.Vector3(-pathDirection.z, 0, pathDirection.x).normalize();
                
                // Look left from the first coordinate
                const lookAtPoint = firstCoordinate.clone().add(leftDirection);
                camera.lookAt(lookAtPoint);
                controls.target.copy(lookAtPoint);
                controls.update();
            }
            
            // Start camera following immediately
            cameraFollowing = true;
            
            // Wait 1 second before starting to walk
            setTimeout(() => {
                isWalking = true;
                walkingProgress = 0;
            }, 2000);
        }
        
        function clearPath() {
            isWalking = false;
            walkingProgress = 0;
            cameraFollowing = false;
            
            if (pathLine) {
                scene.remove(pathLine);
                pathLine = null;
            }
            
            // Clear arrival message if it exists
            hideArrivalMessage();
            
            personModel.visible = false;
            
            currentPath = null;
        }

      // Load model with optimized loading (but don't add to scene)
      async function loadModel() {
  return new Promise((resolve, reject) => {
    try {
      const loader = new THREE.GLTFLoader();

        loader.load(
          'nwssu.glb',
          (gltf) => {
            const model = gltf.scene;

            // Scale to fit
            const bbox = new THREE.Box3().setFromObject(model);
            const size = bbox.getSize(new THREE.Vector3());
            const maxDimension = Math.max(size.x, size.y, size.z);
            const scale = 50 / maxDimension;
            model.scale.setScalar(scale);

            model.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });

            resolve(model);
          },
          (xhr) => {
            if (xhr.total) {
              const percent = Math.round((xhr.loaded / xhr.total) * 100);
              const progressFill = document.getElementById("progress-fill");
              const progressText = document.getElementById("progress-text");

              const overallPercent = 40 + (percent * 0.6);
              if (progressFill) progressFill.style.width = `${overallPercent}%`;
              if (progressText) progressText.textContent = `Loading model: ${percent}%`;
            }
          },
          (error) => {
            console.error('Error loading model from nwssu.glb:', error);
            console.log('Creating placeholder model instead...');
          const placeholder = createPlaceholderModel();
          resolve(placeholder);
          }
        );
      
    } catch (error) {
      console.error("Exception in model loading:", error);
      const placeholder = createPlaceholderModel();
      resolve(placeholder);
    }
  });
}

        function createPlaceholderModel() {
            const campusGroup = new THREE.Group();
            
            // Create some buildings
            const building1 = new THREE.Mesh(
                new THREE.BoxGeometry(4, 3, 4),
                new THREE.MeshLambertMaterial({ color: 0x8888ff })
            );
            building1.position.set(-5, 1.5, 5);
            campusGroup.add(building1);
            
            const building2 = new THREE.Mesh(
                new THREE.BoxGeometry(5, 4, 3),
                new THREE.MeshLambertMaterial({ color: 0xff8888 })
            );
            building2.position.set(5, 2, 3);
            campusGroup.add(building2);
            
            const building3 = new THREE.Mesh(
                new THREE.BoxGeometry(6, 5, 5),
                new THREE.MeshLambertMaterial({ color: 0x88ff88 })
            );
            building3.position.set(0, 2.5, -5);
            campusGroup.add(building3);
            
            const building4 = new THREE.Mesh(
                new THREE.BoxGeometry(3, 2, 3),
                new THREE.MeshLambertMaterial({ color: 0xffff88 })
            );
            building4.position.set(-7, 1, -3);
            campusGroup.add(building4);
            
            return campusGroup;
        }
        
        function onWindowResize() {
            camera.aspect = document.getElementById('canvas-container').offsetWidth / document.getElementById('canvas-container').offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(document.getElementById('canvas-container').offsetWidth, document.getElementById('canvas-container').offsetHeight);
        }
        
        function updateCameraRotation(delta) {
            // No camera rotation updates needed - orbit controls handle everything
        }
        
        // Function to determine if stair camera should be used based on floor differences
        function shouldUseStairCameraForCurrentPath() {
            // Get the current location names from the selected dropdowns
            let startLocationName, endLocationName;
            
            // Check if we have CCIS location selections first
            if (selectedLocationA && selectedLocationB) {
                startLocationName = selectedLocationA;
                endLocationName = selectedLocationB;
            } else if (selectedFromPoint && selectedToPoint) {
                // Use regular from/to selection
                startLocationName = selectedFromPoint;
                endLocationName = selectedToPoint;
            } else {
                console.log('Could not find start or end location names for floor comparison');
                return false;
            }
            
            // Get location data directly from CAMPUS_POINTS using the location names
            const startLocation = CAMPUS_POINTS[startLocationName];
            const endLocation = CAMPUS_POINTS[endLocationName];
            
            if (!startLocation || !endLocation) {
                console.log(`Could not find location data for ${startLocationName} or ${endLocationName}`);
                return false;
            }
            
            // Check if floors are different
            const startFloor = startLocation.floor;
            const endFloor = endLocation.floor;
            
            const shouldUseStair = startFloor !== endFloor;
            console.log(`Floor comparison: ${startLocationName} (floor ${startFloor}) -> ${endLocationName} (floor ${endFloor}), Use stair camera: ${shouldUseStair}`);
            
            return shouldUseStair;
        }
        
        function updateCameraFollow() {
            if (!cameraFollowing || !isWalking) return;
            
            // Check if we're at the last coordinate - always use default camera
            const isAtLastCoordinate = isPersonAtLastCoordinate();
            
            if (isAtLastCoordinate) {
                console.log('At last coordinate, using default third-person view');
                useDefaultCamera();
                return;
            }
            
            // Check if we need to use stair camera based on floor differences
            const shouldUseStairCamera = shouldUseStairCameraForCurrentPath();
            console.log(`Should use stair camera: ${shouldUseStairCamera}, Person position:`, personModel.position);
            
            if (shouldUseStairCamera) {
                // Check if person is near any stair camera position
                const stairArea = getStairCameraPosition(personModel.position);
                console.log(`Stair area detected: ${stairArea}`);
                
                if (stairArea) {
                    console.log(`Using stair camera for area: ${stairArea}`);
                    // Use the specific camera position and target for this stair area
                    const cameraPos = CAMERA_POSITIONS[stairArea];
                    if (cameraPos) {
                        camera.position.set(...cameraPos.position);
                        camera.lookAt(...cameraPos.target);
                        controls.target.set(...cameraPos.target);
                        controls.update();
                        return;
                    }
                } else {
                    console.log('Stair camera should be used but person not near stair area, using third-person view');
                }
            }
            
            // Default third-person view
            useDefaultCamera();
        }
        
        // Function to check if person is at the last coordinate
        function isPersonAtLastCoordinate() {
            if (!currentPath || currentPath.length < 2) return true;
            
            const totalLength = currentPath.length - 1;
            const scaledProgress = walkingProgress * totalLength;
            const currentIndex = Math.floor(scaledProgress);
            
            const isAtLast = currentIndex >= currentPath.length - 1;
            console.log(`Last coordinate check: walkingProgress=${walkingProgress.toFixed(3)}, scaledProgress=${scaledProgress.toFixed(3)}, currentIndex=${currentIndex}, pathLength=${currentPath.length}, isAtLast=${isAtLast}`);
            
            // Check if we're at the last coordinate (index length-1)
            return isAtLast;
        }
        
        // Function to set default third-person camera view
        function useDefaultCamera() {
            console.log('Using default third-person camera');
            const eyeLevel = 0.06; // Lower eye level
            const distanceBack = 0.3; // Distance back to see the person
            
            // Calculate camera position behind the person in the opposite direction of movement
            const cameraDirection = personDirection.clone().multiplyScalar(-distanceBack);
            cameraDirection.y = eyeLevel; // Set the height
            
            // Set camera to person's position with offset
            camera.position.copy(personModel.position).add(cameraDirection);
            
            // Look in the direction the person is moving
            const lookAtPoint = personModel.position.clone().add(personDirection);
            camera.lookAt(lookAtPoint);
            
            // Update controls target to maintain smooth camera movement
            controls.target.copy(lookAtPoint);
            controls.update();
        }
        
        // Function to create and show arrival message as DOM overlay
        function showArrivalMessage() {
            console.log('showArrivalMessage called'); // Debug log
            
            // Create DOM overlay message
            const messageDiv = document.createElement('div');
            messageDiv.id = 'arrival-message';
            messageDiv.innerHTML = 'You have reached your destination!';
            messageDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 255, 0, 0.9);
                color: black;
                padding: 20px 40px;
                border-radius: 10px;
                font-size: 24px;
                font-weight: bold;
                z-index: 10000;
                box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
                border: 2px solid #00ff00;
                text-align: center;
                font-family: Arial, sans-serif;
            `;
            
            document.body.appendChild(messageDiv);
            console.log('DOM message added'); // Debug log
            
            // Auto-hide message after 4 seconds
            setTimeout(() => {
                hideArrivalMessage();
            }, 4000);
        }
        
        function hideArrivalMessage() {
            const messageDiv = document.getElementById('arrival-message');
            if (messageDiv) {
                messageDiv.remove();
                console.log('DOM message removed'); // Debug log
            }
        }
        
        // Function to calculate total path length
        function calculatePathLength(path) {
            let totalLength = 0;
            for (let i = 0; i < path.length - 1; i++) {
                const start = path[i];
                const end = path[i + 1];
                const distance = Math.sqrt(
                    Math.pow(end.x - start.x, 2) +
                    Math.pow(end.y - start.y, 2) +
                    Math.pow(end.z - start.z, 2)
                );
                totalLength += distance;
            }
            return totalLength;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = 0.0167; // Approximate 60fps
            
            // Update camera rotation only
            updateCameraRotation(delta);
            
            // Animate person walking
            if (isWalking && currentPath && currentPath.length > 1) {
                // Calculate speed based on path length to maintain constant walking speed
                const pathLength = calculatePathLength(currentPath);
                const baseSpeed = 0.001; // Base speed per frame
                const speedToUse = (baseSpeed / pathLength) * walkingSpeed; // Apply speed multiplier
                
                walkingProgress += speedToUse;

                if (walkingProgress >= 1) {
                    walkingProgress = 1;
                    isWalking = false;
                    cameraFollowing = false;
                    
                    // Calculate left direction relative to final path direction
                    let finalPathDirection;
                    if (currentPath.length > 1) {
                        const lastIndex = currentPath.length - 1;
                        finalPathDirection = new THREE.Vector3().subVectors(currentPath[lastIndex], currentPath[lastIndex - 1]).normalize();
                    } else {
                        finalPathDirection = new THREE.Vector3(0, 0, 1); // Default forward direction
                    }
                    
                    // Calculate left direction (perpendicular to final path direction)
                    const leftDirection = new THREE.Vector3(-finalPathDirection.z, 0, finalPathDirection.x).normalize();
                    
                    // Set person to look left relative to final path direction
                    personDirection = leftDirection;
                    if (personDirection.length() > 0) {
                        personModel.lookAt(personModel.position.clone().add(personDirection));
                    }
                    
                    // Use default camera when destination is reached
                    console.log('Destination reached! Switching to default camera');
                    useDefaultCamera();
                    
                    // Show arrival message when destination is reached
                    console.log('Destination reached!'); // Debug log
                    showArrivalMessage();
                }
                
                const totalLength = currentPath.length - 1;
                const scaledProgress = walkingProgress * totalLength;
                const index = Math.floor(scaledProgress);
                const fraction = scaledProgress - index;
                
                if (index < currentPath.length - 1) {
                    const start = currentPath[index];
                    const end = currentPath[index + 1];
                    
                    personModel.position.lerpVectors(start, end, fraction);
                    // Add height offset to keep person above ground
                    personModel.position.y += 0.03;
                    
                    personDirection = new THREE.Vector3().subVectors(end, start).normalize();
                    if (personDirection.length() > 0) {
                        personModel.lookAt(personModel.position.clone().add(personDirection));
                    }
                    
                    // No bobbing animation - removed the bobOffset line
                }
            }
            
            // Update camera to follow person if enabled
            updateCameraFollow();
            
            renderer.render(scene, camera);
        }
        
        // Start with the home screen
        initHomeScreen();
    </script>
</body>
</html>